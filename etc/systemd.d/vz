#!/bin/bash

VE_PARALLEL=0

VZCTL=/usr/sbin/vzctl
VZLIST=/usr/sbin/vzlist
VZCONF=/etc/vz/vz.conf
OOM_GROUPS_CONF=/etc/vz/oom-groups.conf
SYSFS_PERM=/sys/fs/cgroup/ve/ve.default_sysfs_permissions

get_parallel()
{
	[ -n "${VE_PARALLEL}" -a "${VE_PARALLEL}" != "0" ] && return
	VE_PARALLEL=`awk '
BEGIN { num=0; }
$1 == "processor" { num++; }
END { print num * 4; }' /proc/cpuinfo`
}

setup_oom_groups()
{
	[ ! -f "$OOM_GROUPS_CONF" ] && return
	cat $OOM_GROUPS_CONF > /proc/vz/oom_score_adj 2>/dev/null
}

setup_ve_sysfs()
{
	[ ! -f "$SYSFS_PERM"  ] && return 0

PERM="/ rx
block -
class rx
class/block rx
class/net rx
class/tty rx
class/mem rx
class/misc rx
devices rx
devices/system rx
devices/system/cpu rx
devices/system/cpu/kernel_max r
devices/virtual rx
devices/virtual/misc rx
devices/virtual/misc/tun rx
devices/virtual/misc/tun/dev r
devices/virtual/misc/tun/uevent rw
devices/virtual/net rx
devices/virtual/mem rx
devices/virtual/tty rx
dev rx
dev/block rx
dev/char rx
fs rx
fs/cgroup rw
kernel rx
kernel/fscaps r
kernel/profiling r
kernel/uevent_seqnum r
devices/virtual/mem rx
devices/virtual/mem/full rx
devices/virtual/mem/full/dev r
devices/virtual/mem/full/uevent rw
devices/virtual/mem/null rx
devices/virtual/mem/null/dev r
devices/virtual/mem/null/uevent rw
devices/virtual/mem/random rx
devices/virtual/mem/random/dev r
devices/virtual/mem/random/uevent rw
devices/virtual/mem/urandom rx
devices/virtual/mem/urandom/dev r
devices/virtual/mem/urandom/uevent rw
devices/virtual/mem/zero rx
devices/virtual/mem/zero/dev r
devices/virtual/mem/zero/uevent rw
devices/virtual/tty/ptmx rx
devices/virtual/tty/ptmx/dev r
devices/virtual/tty/ptmx/uevent rw"

	local ifs=$IFS
	IFS="
"
	for i in $PERM; do
        	echo "$i" > $SYSFS_PERM 2>/dev/null
	done
	IFS=$ifs

	echo "devices/system/cpu/ rx" > $SYSFS_PERM
	for i in `ls -1d /sys/devices/system/cpu/cpu[0-9]*`; do
		echo "$i" | sed s,/sys/,,g | sed 's/$/ rx/' > $SYSFS_PERM
	done
}

get_physical_interfaces()
{
	local link target
	for link in $(find /sys/class/net -type l); do
		target=$(readlink -f "${link}")
		# Only physical
		[[ "${target}" == "/sys/devices/virtual"* ]] && continue
		basename "${link}"
	done
}

setup_net()
{
	local hwcsum_set=1 tso_set=1 val
	local rx=on tx=on sg=on tso=on
	local ethtool_args= iface_params
	# We do not want to export the whole config file.
	eval $(. ${VZCONF} && echo USE_NET_TSO="${USE_NET_TSO}" \
		USE_NET_HWCSUM="${USE_NET_HWCSUM}")

	if [ "${USE_NET_HWCSUM}" = "yes" ]; then
		ethtool_args="${ethtool_args} rx on tx on sg on"
	elif [ "${USE_NET_HWCSUM}" = "no" ]; then
		ethtool_args="${ethtool_args} rx off tx off sg off"
	else
		hwcsum_set=0
	fi

	if [ "${USE_NET_TSO}" = "yes" ]; then
		ethtool_args="${ethtool_args} tso on"
	elif [ "${USE_NET_TSO}" = "no" ]; then
		ethtool_args="${ethtool_args} tso off"
	else
		tso_set=0
	fi

	if [[ ${hwcsum_set} -eq 0 || ${tso_set} -eq 0 ]]; then
		# Get minimal common subset of capabilities.
		for iface in $(get_physical_interfaces); do
			iface_params=$(ethtool -k "${iface}" | awk '
				/^rx-checksumming:/{print "rx", $2};
				/^tx-checksumming:/{print "tx", $2};
				/^scatter-gather:/{print "sg", $2};
				/^tcp-segmentation-offload:/{print "tso", $2}')
			for param in rx tx sg tso; do
				val=$(echo "${iface_params}" | awk "/${param}/{print \$2}")
				[ "${val}" = "off" ] && eval ${param}=off
			done
		done
		[ ${hwcsum_set} -eq 0 ] && ethtool_args="${ethtool_args} rx ${rx} tx ${tx} sg ${sg}"
		[ ${tso_set} -eq 0 ] && ethtool_args="${ethtool_args} tso ${tso}"
	fi
	[ -n "${ethtool_args}" ] && ethtool -K venet0 ${ethtool_args} &>/dev/null
	return 0
}

start()
{
	setup_oom_groups
	setup_ve_sysfs
	setup_net
}

stop()
{
	local cmd pid pids cmd iter velist veid
	local stages="prepare stop"

	get_parallel

	velist=`$VZLIST -H -o ctid`
	for stage in $stages; do
		for veid in $velist; do
			case $stage in
			prepare)
				$VZCTL --skiplock set $veid --cpulimit 0 --iolimit 0 --iopslimit 0 >/dev/null 2>&1
				continue
				;;
			stop)
				cmd="$VZCTL --skiplock stop $veid"
				;;
			esac

			# Run command
			$cmd >/dev/null 2>&1 &
			pid=$!
			pids="$pids $pid"
			let iter++
			if [ $iter -ge $VE_PARALLEL ]; then
				for pid in $pids; do
					wait $pid
				done
				pids=
				iter=0
			fi
		done

		for pid in $pids; do
			wait $pid
		done
	done

	# forcible stop the rest
	velist=`$VZLIST -o ctid`
	for veid in $velist; do
		$VZCTL --skiplock stop $veid --force > /dev/null 2>&1
	done

	# Unmount
	velist=`$VZLIST -ao ctid,status | awk '$2=="mounted" {print $1}'`
	for veid in $velist; do
		$VZCTL --skiplock umount $veid > /dev/null 2>&1
	done
}

case "$1" in
  start)
	start
	;;
  stop)
        stop
        ;;
  *)
        echo "Usage: $0 start|stop"
        exit 1
esac
